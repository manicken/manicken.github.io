/** Modified from original Node-Red source, for audio system visualization
 * vim: set ts=4:
 * Copyright 2013 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 **/
RED.nodes = (function() {

	var node_defs = {};
	var nodes = [];
	var configNodes = {};
	var links = []; // link structure {source:,sourcePort:,target:,targetPort:};
	var workspaces = [];
	var currentWorkspace = {};
    var iconSets = {};

    var exportedSet = {};
    
	function getNode()
	{
		return {id: id , type:type, name:name, x: xpos, y:ypos, z:ws, wires:[], _def:{}};
	}
	/**
	 * 
	 * @param {getNode} node ignore ():
	 */
	function gotNode(node)
	{

	}
	function useNode()
	{
		var node = getNode();
	}
	/**
	 * this creates a workspace object
	 */
	function createWorkspaceObject(id, label, inputs, outputs, _export, isMain, mainNameType, mainNameExt, isAudioMain, settings, generateCppDestructor, extraClassDeclarations) // export is a reserved word
	{
        // first set all default values if inputs are undefined
        if (_export == undefined) _export = true;
        if (isMain == undefined) isMain = false;
        if (mainNameType == undefined) mainNameType = "tabName";
        if (mainNameExt == undefined) mainNameExt = ".ino";
        if (isAudioMain == undefined) isAudioMain = false;
        if (generateCppDestructor == undefined) generateCppDestructor = false;
        if (extraClassDeclarations == undefined) extraClassDeclarations = "";
        if (settings == undefined){ settings = RED.settings.getChangedSettings(RED.view); console.warn("Converting old global workspace settings to new individual:" + label + " " + id); }
        // return new structure
		return { type:"tab", id:id, label:label, inputs:inputs, outputs:outputs, export:_export, isMain:isMain, mainNameType:mainNameType, mainNameExt:mainNameExt, isAudioMain:isAudioMain/*, nodes:[]*/,generateCppDestructor:generateCppDestructor, extraClassDeclarations:extraClassDeclarations, settings:settings}; // nodes is for future version
	}
	function moveNodeToEnd(node)
	{
		nodes.push(nodes.splice(nodes.indexOf(node), 1)[0]);
	}
	$('#btn-moveWorkSpaceLeft').click(function() { moveWorkSpaceLeft(); });
	$('#btn-moveWorkSpaceRight').click(function() { moveWorkSpaceRight();  });
	function moveWorkSpaceLeft()
	{
		var index = getWorkspaceIndex(RED.view.getWorkspace());
		if (index == 0) return;

		let wrapper=document.querySelector(".red-ui-tabs");
		let children=wrapper.children;
		
		wrapper.insertBefore(children[index], children[index-1]); // children[index] is inserted before children[index-1]
		var wsTemp = workspaces[index-1];
		workspaces[index-1] = workspaces[index];
		workspaces[index] = wsTemp;
		RED.storage.update();
	}
	function moveWorkSpaceRight()
	{
		var index = getWorkspaceIndex(RED.view.getWorkspace());
		if (index == (workspaces.length-1)) return;

		let wrapper=document.querySelector(".red-ui-tabs");
		let children=wrapper.children;
		
		wrapper.insertBefore(children[index+1], children[index]); // children[index+1] is inserted before children[index]

		var wsTemp = workspaces[index+1];
		workspaces[index+1] = workspaces[index];
		workspaces[index] = wsTemp;
		RED.storage.update();
    }
    
	function arraySpliceExample()
	{
		var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 0];
		console.error("original:" + arr);
		var removed = arr.splice(2,2,4,3);
		console.error("removed:" + removed);
		console.error("modified:" + arr);
	}
    /**
     * this initializes the initClassNodeDefCategory if it don't exists
     */
    function initClassNodeDefCategory() {
        if (node_defs["classNodes"] == undefined) {
            node_defs["classNodes"] = {
                label:"Class Nodes", 
                description:"Class/Tab Autogenerated Node Types",
                url:"",
                types:{}
            };
        }
    }
    function Init_BuiltIn_NodeDefinitions() {
        //var str = $("script[data-container-name|='NodeDefinitions']").html();
        //var nodeDefinitions = $.parseJSON(str);
        //if (nodeDefinitions == undefined) return;
        registerGroups(NodeDefinitions);
    }
    function registerGroups(nodeDefinitionsGroups) {
        var nodeDefGroupNames = Object.getOwnPropertyNames(nodeDefinitionsGroups);
        for (var i = 0; i < nodeDefGroupNames.length; i++) {
            var catName = nodeDefGroupNames[i];
            var cat = nodeDefinitionsGroups[catName];
            RED.nodes.registerTypes(cat, catName);
        }
    }
    function registerTypes(nodeDefinitionsGroup, uid, dontReplaceExisting) {
        if (nodeDefinitionsGroup.disabled != undefined && nodeDefinitionsGroup.disabled == true)
            return;
        initNodeDefinitions(nodeDefinitionsGroup, uid);
        var types = nodeDefinitionsGroup["types"];
        if (types == undefined) {
            RED.notify("error @ RED.nodes.registerTypes " + uid + " don't contain a types object", "error", null, 6000);
            console.warn(nodeDefinitionsGroup);
        }
        var typesNames = Object.getOwnPropertyNames(types);
        for (var ti = 0; ti < typesNames.length; ti++) {
            var typeName = typesNames[ti];
            var type = types[typeName];
            registerType(typeName, type, uid, dontReplaceExisting);
        }
    }
    function initNodeDefinitions(nodeDefinitions, uid) {
        if (node_defs[uid] == undefined) {
            node_defs[uid] = nodeDefinitions;
        }
    }
	function registerType(nt,def,nodeDefGroupName,dontReplaceExisting) {
        if (dontReplaceExisting != undefined && dontReplaceExisting == "true") {
            return;
        }
        
        node_defs[nodeDefGroupName].types[nt] = def;

        // fix old type of category def.
        if (def.category.endsWith("-function")) def.category = def.category.replace("-function", "");

        if (def.defaults == undefined) return; // discard this node def

        if (def.defaults.color == undefined) def.defaults.color = {};
        if (def.defaults.color.value == undefined) def.defaults.color.value = def.color;

        if (def.inputTypes != undefined) {
            def.inputTypes = convertPortTypeRange(def.inputTypes);
            def.inputs = Object.getOwnPropertyNames(def.inputTypes).length;
        }
        if (def.outputTypes != undefined) {
            def.outputTypes = convertPortTypeRange(def.outputTypes);
            def.outputs = Object.getOwnPropertyNames(def.outputTypes).length;
        }

        try{
		// TODO: too tightly coupled into palette UI
		if (def.dontShowInPalette == undefined)
            RED.palette.add(nt,def,undefined,nodeDefGroupName);
        }
        catch (ex) { console.error(ex);RED.notify("<strong>Warning</strong>: Fail to add this type to the palette<br>" + nt,"warning");} // failsafe
	}

    function convertPortTypeRange(types) {
        var newList = {};
        var ti = 0;
        var typeNames = Object.getOwnPropertyNames(types);
        for (var i = 0; i < typeNames.length; i++) {
            var tn = typeNames[i];
            if (tn.startsWith('x')) {
                var count = parseInt(tn.substring(1));
                for (var ci = 0; ci < count; ci++, ti++)
                    newList[ti] = types[tn];
            }
            else if (tn == "n") {
                return {"n":types.n}; // type n will override everything
            }
            else newList[tn] = types[tn];
        }
        return newList;
    }

	function getID() {
		var str = (1+Math.random()*4294967295).toString(16);
		console.log("getID = " + str);
		return str;
	}

	function checkID(id) {
		var i;
		for (i=0;i<nodes.length;i++) {
			//console.log("checkID, nodes[i].id = " + nodes[i].id);
			if (nodes[i].id == id) return true;
		}
/*
		for (i in workspaces) {
			if (workspaces.hasOwnProperty(i)) { }
		}
		for (i in configNodes) {
			if (configNodes.hasOwnProperty(i)) { }
		}
*/
		return false;
	}
	function checkName(name, wsId, node) { // jannik add
		var i;
		for (i=0;i<nodes.length;i++) {
			//console.log("checkID, nodes[i].id = " + nodes[i].id);
			if (wsId && (wsId != nodes[i].z)) continue; // skip nodes that is not in current workspace
            if (nodes[i]._def.nonObject != undefined) continue; // don't check against nonObjects
            if (nodes[i] == node) continue; // don't check against itself
            var splitStarting = nodes[i].name.split('['); // get array name without array def,

			if (splitStarting[0] == name) return true;
		}
/*
		for (i in workspaces) {
			if (workspaces.hasOwnProperty(i)) { }
		}
		for (i in configNodes) {
			if (configNodes.hasOwnProperty(i)) { }
		}
*/
		return false;
	}

	function createUniqueCppName(n, wsId, nameShouldEndWithNumber) {
		//console.log("getUniqueCppName, n.type=" + n.type + ", n.name=" + n.name + ", n._def.shortName=" + n._def.shortName);
		var basename = n.name; //(n._def.shortName) ? n._def.shortName : n.type.replace(/^Analog/, "");
		if (!checkName(basename, wsId)) return basename; // no need to change
		var count = 1;
        if (nameShouldEndWithNumber == undefined) {
            //console.log("generate name from: " + basename);
            var ret = getBaseName(basename);
            basename = ret.basename;
            count = ret.count;
        }
        else
        {
            var sep = /[0-9]$/.test(basename) ? "_" : ""; // expression checks if basename ends with a number, sep = seperator
            basename = basename + sep;
        }
		//console.log("getUniqueCppName, using basename=" + basename);
		
		//
        //console.log("sep:" + sep);
		var name;
		while (1) {
			//name = basename + sep + count;
            name = basename + count;
			if (!checkName(name, wsId)) break;
			count++;
		}
		//console.log("getUniqueCppName, unique name=" + name);
		return name;
	}
    function getBaseName(name) {
        var index = name.length - 1;
        var number = "";
        while (index >= 0 && charIsNumber(name[index])) {
            number = name[index] + number;
            index--;
        }
        var basename = name.substring(0, index+1);
        //console.log(basename + " " + number);
        if (number == "") number = "1";
        return {basename:basename, count:parseInt(number)};
    }
    function charIsNumber(char) {
        return (char >= '0') && (char <= '9');
    }
	
	function createUniqueCppId(n, workspaceName) {
		//console.log("getUniqueCppId, n.type=" + n.type + ", n.name=" + n.name + ", n._def.shortName=" + n._def.shortName);
		var basename = (n._def.shortName) ? n._def.shortName : n.type.replace(/^Analog/, "");
		
		if (workspaceName)
			basename = workspaceName + "_" + basename; // Jannik added

		//console.log("getUniqueCppId, using basename=" + basename);
		var count = 1;
		var sep = /[0-9]$/.test(basename) ? "_" : "";
		var name;
		while (1) {
			name = basename + sep + count;
			if (!checkID(name)) break;
			count++;
		}
		//console.log("getUniqueCppId, unique id=" + name);
		return name;
	}

	function getUniqueName(n) {
		var newName = n.name;
		if (typeof newName === "string") {
			var parts = newName.match(/(\d*)$/);
			var count = 0;
			var base = newName;
			if (parts) {
				count = isNaN(parseInt(parts[1])) ? 0 : parseInt(parts[1]);
				base = newName.replace(count, "");
			}
			while (RED.nodes.namedNode(newName) !== null) {
				count += 1;
				newName = base + count;
			}
		}
		return newName;
	}

	function getType(type) {
        var defCatNames = Object.getOwnPropertyNames(node_defs);
        for (var i = 0; i < defCatNames.length; i++) {
            var defCatName = defCatNames[i];
            var defCat = node_defs[defCatName];
            if (defCat.types[type] != undefined) return defCat.types[type];
        }
        console.error("did not found type: " + type);
		return undefined;
	}
	function selectNode(name) {
        var info = "";
        if (name.trim() != "") info = '?info=' + name;
		if (!((document.origin == 'null') && (window.chrome))) {
			window.history.pushState(null, null, window.location.protocol + "//"
				+ window.location.host + window.location.pathname + info);
		}
	}
	/**
	 * 
	 * @param {Node} n 
	 */
	function addNode(n,index) {
		/*if (n.type == "AudioMixerX")
		{
			if (!n.inputs)
				n.inputs = n._def.inputs;
		}*/
        		
        n.dirty = true;
        if (index == undefined)
            nodes.push(n);
        else
            nodes.splice(index,1,n);
        //console.warn("addNode:");
        //console.warn(n);
        RED.events.emit('nodes:add',n);
	}
	function addLink(l) {
		links.push(l);
        RED.events.emit('links:add',l);
	}

	function checkForIO() {
		var hasIO = false;
		RED.nodes.eachNode(function (node) {

			if (node._def.category.startsWith("input-") ||
				node._def.category.startsWith("output-")) {
				hasIO = true;
			}
		});
		return hasIO;
	}

    function checkForAudio() {
		var hasAudio = false;
		RED.nodes.eachNode(function (node) {

			if (node.type.includes("Audio")) {
				hasAudio = true;
			}
		});
		return hasAudio;
	}

	function getNode(id) {
		if (id in configNodes) {
			return configNodes[id];
		} else {
			for (var n in nodes) {
				if (nodes[n].id == id) {
					return nodes[n];
				}
			}
		}
		return null;
	}

	function getNodeByName(name,nns) {
        if (nns == undefined) nns = nodes;
		for (var n in nns) {
			if (nns[n].name == name) {
				return nns[n];
			}
		}
		return null;
	}
	

	function removeNode(id) {
		var removedLinks = [];
		
        var node = getNode(id);
        
        if (!node) return removedLinks; // cannot continue if node don't exists

        if (node.type == "TabInput" || node.type == "TabOutput")
        {
            //TODO: do the removal of external connected wires // now fixed
            //console.warn("TODO: do the removal of external connected wires"); // now fixed
            var wsLabel = getWorkspaceLabel(RED.view.getWorkspace());
            RED.console_ok("workspace label:" + wsLabel);
            refreshClassNodes();
        }
        nodes.splice(nodes.indexOf(node),1);
        removedLinks = links.filter(function(l) { return (l.source === node) || (l.target === node); });
        removedLinks.map(function(l) {links.splice(links.indexOf(l), 1); });
		
        // to use with OSC event
        RED.events.emit('nodes:removed', node, removedLinks);

        // normal event
        RED.events.emit('nodes:remove',node);
			
		return removedLinks;
	}

	function removeLink(l) {
		var index = links.indexOf(l);
		if (index != -1) {
			links.splice(index,1);
		}
        RED.events.emit('links:remove',l);
	}

	function refreshValidation() {
		for (var n=0;n<nodes.length;n++) {
			RED.editor.validateNode(nodes[n]);
		}
	}

	function addWorkspace(ws) {
		workspaces.push(ws);
		currentWorkspace = ws;
        addClassTabsToPalette();
        RED.events.emit('flows:add',ws);
	}
	function getWorkspaceLabel(id)
	{
		//console.warn("getWorkspaceLabel:" +id);
		for (var i = 0; i < workspaces.length; i++)
		{
			if (workspaces[i].id == id)
				return workspaces[i].label;
		}
		return undefined;
	}
	function getWorkspaceIndex(id)
	{
		for (var i = 0; i < workspaces.length; i++)
		{
			if (workspaces[i].id == id)
				return i;
		}
		return -1;
	}
	function getWorkspace(id) {
		for (var i = 0; i < workspaces.length; i++)
		{
			if (workspaces[i].id == id)
				return workspaces[i];
		}
		return null;
	}
	function removeWorkspace(id) {
		console.trace("workspace removed " + id);
        var index = getWorkspaceIndex(id);
        var ws = workspaces[index];
		var wsLbl = ws.label;
		if (index != -1) workspaces.splice(index, 1);
		
		var removedNodes = [];
		var removedLinks = [];
		var n;
		for (n=0;n<nodes.length;n++) {
			var node = nodes[n];
			if (node.z == id) {
				removedNodes.push(node);
			}
		}
		for (n=0;n<removedNodes.length;n++) {
			var rmlinks = removeNode(removedNodes[n].id);
			removedLinks = removedLinks.concat(rmlinks);
		}
		if (node_defs["classNodes"].types[wsLbl] != undefined)
		{
			delete node_defs["classNodes"].types[wsLbl];

			console.log("class type deleted "+ wsLbl);
		}
		removeClassNodes(wsLbl);
		addClassTabsToPalette();
        refreshClassNodes();
        RED.events.emit('flows:remove',ws);
		return {nodes:removedNodes,links:removedLinks};
	}

	function getAllFlowNodes(node) {
		var visited = {};
		visited[node.id] = true;
		var nns = [node];
		var stack = [node];
		while(stack.length !== 0) {
			var n = stack.shift();
			var childLinks = links.filter(function(d) { return (d.source === n) || (d.target === n);});
			for (var i=0;i<childLinks.length;i++) {
				var child = (childLinks[i].source === n)?childLinks[i].target:childLinks[i].source;
				if (!visited[child.id]) {
					visited[child.id] = true;
					nns.push(child);
					stack.push(child);
				}
			}
		}
		return nns;
	}
	function getNodesIds(nodes)
	{
		if (nodes == undefined) return [];
		var nids = [];
		for (var i = 0; i < nodes.length; i++)
		{
			if (nodes[i] == undefined) continue;
			nids.push(nodes[i].id);
		}
		return nids;
	}
	/**
	 * Converts a node to an exportable JSON Object
	 **/
	function convertNode(n) {
        
		var node = {};
		node.id = n.id;
		node.type = n.type;
        if (n._def.isClass != undefined)
            node.isClass = true; // just for the export to quick check if class
        else
            node.isClass = false;

		for (var d in n._def.defaults) {
			if (n._def.defaults.hasOwnProperty(d)) {
				if (d === "nodes")
					node[d] = getNodesIds(n[d]);
				else if (d != "color")
					node[d] = n[d];
			}
		}
		if (n.parentGroup != undefined)
		{
			node.parentGroup = n.parentGroup.id;
		}
		
        node.x = n.x;
        node.y = n.y;
        node.z = n.z;
        node.bgColor = n.bgColor;
        node.wires = [];
        //node.wireNames = [];
        for(var i=0;i<n.outputs;i++) {
            node.wires.push([]);
            //node.wireNames.push([]);
        }
        var wires = links.filter(function(d){return d.source === n;});
        for (var j=0;j<wires.length;j++) {
            var w = wires[j];
            try{
            node.wires[w.sourcePort].push(w.target.id + ":" + w.targetPort);
            //node.wireNames[w.sourcePort].push(RED.export.GetLinkName(w));
            }
            catch (e)
            {
                // when a TabInput/TabOutput is removed and that pin is connected to parent flow

            }
        }

		//console.warn("convert node: " + n.name);
		//console.warn("from:" + Object.getOwnPropertyNames(n._def));
		//console.warn("to:" + Object.getOwnPropertyNames(node));
		return node;
	}

	/**
	 * Converts the current node selection to an exportable JSON Object
	 **/
	function createExportableNodeSet(set) {
		var nns = [];
		var exportedConfigNodes = {};
		for (var n=0;n<set.length;n++) {
			var node = set[n].n;
			var convertedNode = RED.nodes.convertNode(node);
			for (var d in node._def.defaults) {
				if (node._def.defaults[d].type && node[d] in configNodes) {
					var confNode = configNodes[node[d]];
					var exportable = getType(node._def.defaults[d].type).exportable;
					if ((exportable == null || exportable)) {
						if (!(node[d] in exportedConfigNodes)) {
							exportedConfigNodes[node[d]] = true;
							nns.unshift(RED.nodes.convertNode(confNode));
						}
					} else {
						convertedNode[d] = "";
					}
				}
			}

			nns.push(convertedNode);
		}
		return nns;
	}

    function sortNodes() {
        //console.error("nodecount before sort: "+nodes.length);
        var sortedNodes = [];
        for (wsi=0;wsi<workspaces.length;wsi++)
		{
			ws = workspaces[wsi];

            var absoluteXposMax = 0;
            var absoluteYposMax = 0;
            var workspaceColSize = RED.view.defSettings.gridVmajorSize;
            
            // if the ws.settings.gridVmajorSize is defined then use that instead
            if (ws.settings.gridVmajorSize != undefined) workspaceColSize = ws.settings.gridVmajorSize;
            // calculate absolute node max and min positions
            for (var ni = 0; ni < nodes.length; ni++)
            {
                var node = nodes[ni];
                if (node.z != ws.id) continue; // workspace filter
                if (node.x > absoluteXposMax) absoluteXposMax = node.x;
                if (node.y > absoluteYposMax) absoluteYposMax = node.y;
            }
            // ensure that every node is included 
            absoluteXposMax += workspaceColSize*4; 
            absoluteYposMax += RED.view.node_def.height*4;
            var otherNodes = [];
			// sort audio nodes by columns (xpos)
			for (var xPosMin = 0; xPosMin < absoluteXposMax; xPosMin+=workspaceColSize)
			{
				var nnsCol = []; // current column
				var xPosMax = xPosMin+workspaceColSize;

				for (ni=0;ni<nodes.length;ni++)
				{
					var node = nodes[ni];
					if (node.z != ws.id) continue; // workspace filter

					if (node._def.uiObject != undefined) continue; // skip 'ui nodes' they are added down (and should never be sorted because then it will mess up ui layout)
                    if (node.type == "TabInput" || node.type == "TabOutput") continue; // skip TabInputs TabOutputs they are added down

					if ((node.x >= xPosMin) && (node.x < xPosMax))
						nnsCol.push(node);
				}
				// sort "new" nodes by ypos
				nnsCol.sort(function(a,b){return(a.y-b.y);});
                otherNodes.pushArray(nnsCol);
            }
            var classIOnodes = [];
            var uiNodes = [];
            // add ui nodes last and as they are in draw order
			for (var ni=0;ni<nodes.length;ni++)
			{
				var node = nodes[ni];
				if (node.z != ws.id) continue; // workspace filter
                if (node.type == "TabInput" || node.type == "TabOutput") { // handle TabInputs TabOutputs separately as they should be sorted top to bottom regardless of x pos
                    classIOnodes.push(node);
                    continue;
                }
				if (node._def.uiObject == undefined) continue; // skip other non ui nodes
                // just add ui nodes as is to preserve draw order
                uiNodes.push(node);
			}
            classIOnodes.sort(function(a,b){return(a.y-b.y);});
            sortedNodes.pushArray(uiNodes);
            sortedNodes.pushArray(classIOnodes);
            sortedNodes.pushArray(otherNodes);
		}
        nodes.length = 0;
        nodes.pushArray(sortedNodes);
        //console.error("nodecount after sort: "+nodes.length);
    }
	function copyWorkspace(ws) {
        return JSON.parse(JSON.stringify(ws));
    }

	function createCompleteNodeSet(args) {
        var newVersion;
        var sort;
        if (args == undefined) args = {};
        if (args.newVer == undefined) newVersion = false;
        else newVersion = args.newVer;
        if (args.sort == undefined) sort = true; // default is allways sort
        else sort = args.sort;

        if (sort == true) sortNodes();

		if(newVersion == true) var project = {version:1};
        else var nns = [];
        
        if (newVersion == true)
            project.settings = RED.settings.getAsJSONobj();
        else
            nns.push({"type":"settings", "data":RED.settings.getAsJSONobj()});
        
        if (newVersion == false) {
            // first add all workspaces/tabs to the nns
            for (let wsi=0;wsi<workspaces.length;wsi++) {
                nns.push(workspaces[wsi]);
            }
        }
		var _workspaces = [];
		// sort nodes by workspace
		for (var wsi=0;wsi<workspaces.length;wsi++)
		{
 			var ws = copyWorkspace(workspaces[wsi]); // so that we don't work with the active set, that resulted in a nasty suprice once
            //console.log(ws);
            if (newVersion == true)
                ws.nodes = [];

            for (var ni = 0; ni < nodes.length; ni++) {
                var node = nodes[ni];
                if (node.z != ws.id) continue; // workspace filter

                if (newVersion == true)
                    ws.nodes.push(convertNode(node));
                else
				    nns.push(convertNode(node)); 
            }
            _workspaces.push(ws);
		}
        if (newVersion == true) {
            project.workspaces = _workspaces;
            project.nodeAddons = getNodeAddons();
            exportedSet = workspaces;
            return project;
        }
        else {
            exportedSet = nns;
		    return nns;
        }
	}

    function getNodeAddons() {
        var naddons = {};
        var ndcn = Object.getOwnPropertyNames(node_defs);
        for (var ndi = 0; ndi < ndcn.length; ndi++) {
            var ndn = ndcn[ndi];
            var nd = node_defs[ndn];
            if (nd.isAddon != undefined && nd.isAddon == true) {
                naddons[ndn] = nd;
            }
            //else console.warn("skippin ", nd);
        }
        return naddons;
    }
	
	
	function createNewDefaultWorkspace() // Jannik Add function
	{
		console.trace();
		if (workspaces.length != 0) return;
		var newWorkspace = createWorkspaceObject("Main","Main",0,0);
		console.warn("add new default workspace Main");
		addWorkspace(newWorkspace);
		RED.view.addWorkspace(newWorkspace);
	}

	function importWorkspaces(newNodes, createNewIds)
	{
		var newWorkspaces = [];
        // scan and load workspaces and settings first
        for (i=0;i<newNodes.length;i++) { 
            n = newNodes[i];
            
            // filter for workspace and tab types
            if (n.type !== "tab" && n.type !== "workspace") continue;

            if (n.type === "workspace") n.type = "tab"; // type conversion

            var cIOs = getClassIOportCounts(n.id, newNodes);
            var ws = createWorkspaceObject(n.id, n.label, cIOs.inCount, cIOs.outCount, n.export, n.isMain, n.mainNameType, n.mainNameExt, n.isAudioMain, n.settings, n.generateCppDestructor, n.extraClassDeclarations);
            
            addWorkspace(ws);
            newWorkspaces.push(ws);
            
            //console.warn("added new workspace lbl:" + ws.label + ",inputs:" + ws.inputs + ",outputs:" + ws.outputs + ",id:" + ws.id);

            initClassNodeDefCategory();
            registerType(ws.label, getClassNodeDefinition(ws.label, ws.inputs, ws.outputs), "classNodes");
        }
        RED.storage.dontSave = true; // prevent save between tab switch
        for (i=0; i < newWorkspaces.length; i++) {
            RED.view.addWorkspace(newWorkspaces[i]); // "final" function is in tabs.js
        }
        RED.storage.dontSave = false;
	}

    // new version import workspace nodes
    function importWorkspaceNodes(workspaces, createNewIds) {
        for (var i = 0; i < workspaces.length; i++) {
            var ws = workspaces[i];
            // failsafe check
            if (ws.nodes != undefined && ws.nodes.length != 0) {
                importNewNodes(ws.nodes, createNewIds);
            }
        }
    }

    function loadAndApplySettings(jsonObj) {
        for (i=0;i<jsonObj.length;i++) { 
            n = jsonObj[i];
            if (n.type !== "settings") continue;
			
            console.warn('Loading Project Settings');
			RED.settings.setFromJSONobj(n.data);
			return;
        }
    }

    function isNewVersion(newNodes) {
        // new version have either of theese defined
        if (newNodes.version != undefined)
            return true;
        else if (newNodes.workspaces != undefined)
            return true;
        else if (newNodes.settings != undefined)
            return true;
        else if (newNodes.nodeAddons != undefined)
            return true;
        return false;
    }

	function importNodes(newNodesObj, createNewIds, clearCurrentFlow) {
		//console.trace("@ importNodes - createNewIds:" + createNewIds);
		
		var newNodes;
		if (createNewIds == undefined)
			createNewIds = false; // not really necessary?
		if (clearCurrentFlow)
		{
			//console.trace("clear flow");
			//node_defs = {};
			nodes.length = 0;
			//configNodes = {};
			links.length = 0; // link structure {source:,sourcePort:,target:,targetPort:};
			workspaces.length = 0;
			currentWorkspace = {};
		}
		try {
			if (typeof newNodesObj === "string") {
				if (newNodesObj === "") {
					//console.trace("newNodexObj == null create");
					createNewDefaultWorkspace();
					return;
				}
				newNodes = JSON.parse(newNodesObj);
			} else {
				newNodes = newNodesObj;
			}

            if (isNewVersion(newNodes) == true) // this is for the future versions of structure, not yet implemented
            {
                //RED.notify("new json structure detected, ver: " + newNodes.version, "info", null, 2000);
                if (newNodes.settings != undefined) {
                    RED.settings.setFromJSONobj(newNodes.settings);
                }
                //else
                //    RED.notify("newNodes.settings is undefined, using defaults", "warning", null, 2000); //  this is for the future version of structure, not yet implemented
                
                if (newNodes.nodeAddons != undefined) {
                    // here the new node addons loading should happen
                    // I belive the easiest way is to store the node defs inside the project instead of the indexedDB
                    var nodeDefinitionCategoryNames = Object.getOwnPropertyNames(newNodes.nodeAddons);
                    for (var i = 0; i < nodeDefinitionCategoryNames.length; i++) {
                        var catName = nodeDefinitionCategoryNames[i];
                        var cat = newNodes.nodeAddons[catName];
                        registerTypes(cat, catName);
                    }
                }

                if (newNodes.workspaces != undefined)
                {
                    importWorkspaces(newNodes.workspaces, createNewIds);
                    // import the workspace nodes can only be done 
                    // after all workspaces have been loaded in importWorkspaces function above
                    importWorkspaceNodes(newNodes.workspaces, createNewIds);
                }
                else {
                    RED.notify("newNodes.workspaces is undefined, cannot import workspaces", "warning", null, 2000);
                    return;
                }
            }
            else // old version or single node(s) import
            {
                if (!$.isArray(newNodes)) { // if only one node is imported
                    console.warn("@ !$.isArray(newNodes)");
                    newNodes = [newNodes];
                }
                loadAndApplySettings(newNodes);
                importWorkspaces(newNodes);
                if (workspaces.length == 0) {
                    createNewDefaultWorkspace(); // jannik changed to function
                }
                return importNewNodes(newNodes, createNewIds);
            }
		}
		catch(error) { // hijack import errors so that a notification can be shown to the user
			createNewDefaultWorkspace();
			var newException = error.message + " " +  error.stack;
			RED.notify("<strong>import nodes Error</strong>: " + newException, "error",null,false,20000); // better timeout
			throw newException; // throw exception so it can be shown in webbrowser console
		}

	}

    function importNewNodes(newNodes, createNewIds) {
        var i;
		var n;
        // scan and display list of unknown types
        var unknownTypes = [];
        for (i=0;i<newNodes.length;i++) {
            n = newNodes[i];
            //if (n.type == "AudioMixerX") n.type = "AudioMixer"; // type conversion
            if (n.type == "Array") n.type = "PointerArray"; // type conversion
            // TODO: remove workspace in next release+1(Node-Red team comment)
            if (n.type != "workspace" && n.type != "tab" && n.type != "settings" && !getType(n.type)) {
                // TODO: get this UI thing out of here! (see below as well) (Node-Red team comment)
                //n.name = n.type;
                //n.type = "unknown";
                //n.unknownType = true;
                if (unknownTypes.indexOf(n.type + ":" + n.name)==-1) {
                    unknownTypes.push(n.type + ":" + n.name);
                }
                if (n.x == null && n.y == null) {
                    // config node - remove it
                    newNodes.splice(i,1);
                    i--;
                }
            }
        }
        if (unknownTypes.length > 0) {
            var typeList = "<ul><li>"+unknownTypes.join("</li><li>")+"</li></ul>";
            var type = "type"+(unknownTypes.length > 1?"s":"");
            RED.notify("<strong>Imported unrecognised "+type+":</strong>"+typeList,"error",false,10000);
            //"DO NOT DEPLOY while in this state.<br/>Either, add missing types to Node-RED, restart and then reload page,<br/>or delete unknown "+n.name+", rewire as required, and then deploy.","error");
        }

        var node_map = {};
        var new_nodes = [];
        var new_links = [];

        for (i=0;i<newNodes.length;i++) {
            n = newNodes[i];

            // theese two are for backward compatibility
            if (n.type === "workspace" || n.type === "tab") continue;
            else if (n.type === "settings") continue
                
            //if (n.type == "AudioMixerX") n.type = "AudioMixer"; // type conversion
            //console.warn(n);

            var def = getType(n.type);
            if (def != undefined) {
                if (def.uiObject == undefined)
                    var node = {x:n.x,y:n.y,z:n.z,type:n.type,_def:def,wires:n.wires/*,wireNames:n.wireNames*/,changed:false};
                else
                    var node = {x:n.x,y:n.y,z:n.z,w:n.w,h:n.h,type:n.type,_def:def,wires:n.wires/*,wireNames:n.wireNames*/,changed:false};

                if (n.parentGroup != undefined)
                {
                    node.parentGroup = n.parentGroup;
                }

                if (!node._def) {
                    
                    node._def = {
                        color:"#fee",
                        defaults: {"name":{"value":"new"},"id":{"value":"new"},"comment":{"value":""}},
                        label: n.name,
                        labelStyle: "node_label_italic",
                        icon:"arrow-in.png",
                        outputs: n.outputs||n.wires.length,
                        inputs: getNodeInputCount(newNodes, n.z, n.id)
                    }
                    node.unknownType = true;
                    n.bgColor = undefined;
                    node.name = n.name;
                }

                if (createNewIds) { // this is only used by import dialog and paste function
                    node.name = n.name; // set temporary
                    //console.log("@createNewIds srcnode: " + n.id + ":" + n.name);
                    if (n.z == RED.view.getWorkspace())	{ // only generate new names on currentWorkspace
                        node.name = createUniqueCppName(node, n.z); // jannik add
                        //console.warn("make new name: n.name=" + node.name);
                    }
                    else {// this allow different workspaces to have nodes that have same name
                        node.name = n.name;
                        //console.trace("keep name:" + n.name);
                    }
                    // allways create unique id:s
                    node.id = RED.nodes.cppId(node, getWorkspace(RED.view.getWorkspace()).label); // jannik add

                } else {
                    node.name = n.name;
                    node.id = n.id;
                    if (node.z == null || node.z == "0") { //!workspaces[node.z]) {
                        var currentWorkspaceId = RED.view.getWorkspace();
                        console.warn('node.z == null || node.z == "0" -> add node to current workspace ' + currentWorkspaceId);
                        
                        node.z = currentWorkspaceId; // failsafe to set node workspace as current
                    }
                    else if (getWorkspaceIndex(node.z) == -1)
                    {
                        var currentWorkspaceId = RED.view.getWorkspace();
                        console.warn("getWorkspaceIndex("+node.z+") == -1 -> add node to current workspace " + currentWorkspaceId);
                        //console.error(workspaces);
                        node.z = currentWorkspaceId; // failsafe to set node workspace as current
                    }
                }
                for (var d2 in node._def.defaults) {
                    if (node._def.defaults.hasOwnProperty(d2)) {
                        if (d2 == "name" || d2 == "id") continue;
                        node[d2] = n[d2];
                        
                    }
                }
                if (n.bgColor == undefined)	node.bgColor = node._def.color; 
                else node.bgColor = n.bgColor;

                //console.warn(n.name + " " + n.outputs + " " + node._def.outputs);
                node.outputs = n.outputs?n.outputs:node._def.outputs?node._def.outputs:0;
                //console.warn("r√∂vknullad " +node.outputs);

                /*node.outputs_ = 0;
                Object.defineProperty(node, 'outputs', {
                    set: function(value) { console.trace(node.name); this.outputs_ = value;  },
                    get: function() { console.trace(node.name); return this.outputs_; }
                });*/
                

                addNode(node);
                //if (node._def.uiObject != undefined) console.log("node.w:" + node.w + ", node.h:"+ node.h);
                RED.editor.validateNode(node);
                //if (node._def.uiObject != undefined) console.log("node.w:" + node.w + ", node.h:"+ node.h);
                node_map[n.id] = node; // node_map is used for simple access to destinations when generating wires
                new_nodes.push(node);
            }
        }
        // adding the links (wires)
        for (i=0;i<new_nodes.length;i++)
        {
            n = new_nodes[i];
            //console.error(n);
            for (var w1=0;w1<n.wires.length;w1++)
            {
                var wires = (n.wires[w1] instanceof Array)?n.wires[w1]:[n.wires[w1]]; // if not array then convert to array

                for (var w2=0;w2<wires.length;w2++)
                {
                    if (wires[w2] != null) {
                        var parts = wires[w2].split(":");
                        if (parts.length == 2 && parts[0] in node_map) {
                            var dst = node_map[parts[0]];
                            
                            
                            var link = {source:n,sourcePort:w1,target:dst,targetPort:parts[1]};
                            /*
                            if (n.wireNames != undefined) {
                                try {
                                var linkName = n.wireNames[w1][w2];
                                
                                }
                                catch (err) { console.warn(" could not get prev link names  @ " +n.name); var linkName = RED.export.GetLinkName(link);}

                                //console.warn(" got prev link name " + linkName);
                            }
                            else {
                                var linkName = RED.export.GetLinkName(link); 
                                //console.warn( " generating new link name " + linkName);
                                    
                            }
                                

                            link.name = linkName;
                            */
                            addLink(link);
                            new_links.push(link);
                        }
                    }
                }
            }
            if (n.nodes != undefined)
            {
                var newNodesList = [];
                for (var ni = 0; ni < n.nodes.length; ni++)
                {
                    var nodeRef = node_map[n.nodes[ni]];
                    if (nodeRef != undefined) newNodesList.push(nodeRef);
                }
                n.nodes = newNodesList;
            }
            if (n.parentGroup != undefined)
            {
                n.parentGroup = node_map[n.parentGroup]; // convert id to ref
            }
            
            delete n.wires;
            
            //delete n.wireNames;
        }
        return [new_nodes,new_links];
    }
	function findNodeById(newNodes, id)
	{
		for (var i = 0; i < newNodes.length; i++)
		{
			if (newNodes[i].id == id) return newNodes[i];
		}
		return undefined;
	}
	/**
		 * this function checks for !node.wires at beginning and returns if so.
		 * @param {*} srcNode 
		 * @param {*} cb is function pointer with following format cb(srcPortIndex,dstId,dstPortIndex);
		 */
	function eachwire(srcNode, cb) {
		if (!srcNode.wires){ console.log("!node.wires: " + srcNode.type + ":" + srcNode.name); return;}

		//if (srcNode.wires.length == 0) console.log("port.length == 0:" + srcNode.type + ":" + srcNode.name)

		for (var pi=0; pi<srcNode.wires.length; pi++) // pi = port index
		{
			var port = srcNode.wires[pi];
			if (!port){ /*console.log("!port(" + pi + "):" + n.type + ":" + n.name);*/ continue;} // failsafe
			//if (port.length == 0) console.log("portWires.length == 0:"+n.type + ":" + n.name) // debug check
			for (var pwi=0; pwi<port.length; pwi++) // pwi = port wire index
			{
				var wire = port[pwi];
				if (!wire){ /*console.log("!wire(" + pwi + "):" + n.type + ":" + n.name);*/ continue;} // failsafe

				var parts = wire.split(":");
				if (parts.length != 2){ /*console.log("parts.length != 2 (" + pwi + "):" + n.type + ":" + n.name);*/ continue;} // failsafe
				
				var retVal = cb(pi,parts[0],parts[1]);

				if (retVal) return retVal; // only abort/return if cb returns something, and return the value
			}
		}
	}
	/**
	 * 
	 * @param {*} srcNode 
	 * @param {*} cb is function pointer with following format cb(link);
	 */
	function getEachLink(srcNode, cb)
	{
		for (var li = 0; li < links.length; li++)
		{
			var link = links[li];
			if (link.source === srcNode)
			var retVal = cb(link);
			if (retVal) return retVal; // only abort/return if cb returns something, and return the value
		}
	}

	function workspaceNameChanged(oldName, newName)
	{
		var changedCount = 0;
		for (var ni=0;ni<nodes.length;ni++) {
			if (nodes[ni].type == oldName)
			{
				nodes[ni].type = newName;
				changedCount++;
			}
		}
		
		addClassTabsToPalette();
		refreshClassNodes();
		//RED.palette.remove(oldName);
		delete node_defs["classNodes"].types[oldName];

		console.log("workspaceNameChanged:" + oldName + " to " + newName + " with " + changedCount + " objects changed");

		//RED.arduino.httpGetAsync("renameFile:" + oldName + ".h:" + newName + ".h");
	}
	function workspaceNameCheck(newName)
	{
		for (var wsi=0; wsi < workspaces.length; wsi++)
		{
			if (workspaces[wsi].label == newName)
				return true;
		}
		return false;
	}
	/**
	 * this is the internal type,  different from the saved one which is smaller
	 * @typedef {"id":"Main_Array_"+type+"_"+name ,
				 "type":"PointerArray",
				 "name":type + " " + name + " " + cppString,
				 "x":500,"y":55,"z":items[0].n.z,
				 "wires":[],
				 "_def":node_defs["PointerArray"]} Node 
	 */

	/**
	 * this autogenerate a array-node from same-type selection
	 * caller class is tab-info
	 * @param {*} items is of type moving_set from view
	 */
	function generateArrayNode(items)
	{
		var arrayItems = "{";
		var type = items[0].n.type;
		//var name = type.toLowerCase();
		var name = items[0].n.name + "s"

		for (var i = 0; i < items.length ; i++)
		{
			arrayItems += items[i].n.name;
			if (i < (items.length-1)) arrayItems += ",";
		}
		arrayItems += "}";
		addNode({"id":"Main_pArray_"+type+"_"+name ,
				 "type":"PointerArray",
				 "name":name,
				 "objectType":type,
				 "arrayItems":arrayItems,
				 "x":500,"y":500,"z":items[0].n.z,
				 "wires":[],
				 "_def":node_defs["officialNodes"].types["PointerArray"]});
				 RED.view.redraw();
				 RED.storage.update();
	}
	/**
	 * Gets all TabInput and TabOutputs, and then sorting them vertically top->bottom (normal view)
	 * @param {String} wsId workspace id, if this is not passed then all nodes is returned
	 * @returns {tabOutNodes:outNodes, tabInNodes:inNodes}
	 */
	function getClassIOportsSorted(wsId, nns)
	{
		var inNodes = [];
		var outNodes = [];
		if (!nns)
			nns = nodes;
		for (var i = 0; i < nns.length; i++)
		{
			var node = nns[i];
			if (wsId && (node.z != wsId)) continue;

			if (node.type == "TabInput") inNodes.push(convertNode(node, true));
			else if (node.type == "TabOutput") outNodes.push(convertNode(node, true));
		}
		inNodes.sort(function(a,b){ return (a.y - b.y); });
		outNodes.sort(function(a,b){ return (a.y - b.y); });

		return {outputs:outNodes, inputs:inNodes};
	}
	/**
	 * Gets all TabInput and TabOutputs, and then sorting them vertically top->bottom (normal view)
	 * @param {String} wsId workspace id, if this is not passed then all nodes is returned
	 * @returns {outCount:outNodesCount, inCount:inNodesCount}
	 */
	function getClassIOportCounts(wsId, nns)
	{
		var inNodesCount = 0;
		var outNodesCount = 0;
		if (!nns)
			nns = nodes;
		for (var i = 0; i < nns.length; i++)
		{
			var node = nns[i];
			if (wsId && (node.z != wsId)) continue;
            if (node._def == undefined) {
                console.error(node);
                continue;
            }
			if (node.type == "TabInput") inNodesCount++;
			else if (node.type == "TabOutput") outNodesCount++;
		}
		return {outCount:outNodesCount, inCount:inNodesCount};
	}
	/**
	 * Gets all TabInput or TabOutput belonging to a class, and then sorting them vertically top->bottom (normal view)
	 * then the correct port-node based by index is returned
	 * @param {String} wsId workspace id
	 * @param {String} type "TabInput" or "TabOutput"
	 * @returns {tabOutNodes:outNodes, tabInNodes:inNodes}
	 */
	function getClassIOport(wsId, type, index) // this 
	{
        if (!wsId) return;

		var retNodes = [];
		
        var nodeType = "Tab"+type+"put";
		for (var i = 0; i < nodes.length; i++)
		{
			var node = nodes[i];
			if (node.z != wsId) continue;
			if (node.type == nodeType) retNodes.push(node);
		}
		//retNodes.sort(function(a,b){ return (a.y - b.y); }); // this could be avoided if the io nodes where automatically sorted by default
        //console.warn(type + retNodes[index].inputs);
        if (type == "In" && retNodes[index].outputs > 1) {
            return {name:retNodes[index].name + "["+retNodes[index].outputs+"]", node:retNodes[index], isBus:true};
        }
        else if (type == "Out" && retNodes[index].inputs > 1) {
            return {name:retNodes[index].name + "["+retNodes[index].inputs+"]", node:retNodes[index], isBus:true};
        }
		else {
            return {name:retNodes[index].name, node:retNodes[index],isBus:false};
        }
	}
	function getClassComments(wsId)
	{
		var comment = "";
		for (var i = 0; i < nodes.length; i++)
		{
			var node = nodes[i];
			if (wsId && (node.z != wsId)) continue;

			if (node.type != "ClassComment") continue;

			comment += node.name;
		}
		return comment;
	}

	function printLinks() // debug to see links contents
	{
		// link structure {source:n,sourcePort:w1,target:dst,targetPort:parts[1]};
		for (var i = 0; i < links.length; i++)
		{
			var link = links[i];
			console.log("createCompleteNodeSet links["+i+"]: " + 
				link.source.name + ":" + link.sourcePort + ", " + link.target.name + ":" + link.targetPort); 
		}
	}
	function isClass(type)
	{
		for (var wsi = 0; wsi < workspaces.length; wsi++)
		{
			var ws = workspaces[wsi];
			if (type == ws.label) return ws;
			//console.log(node.type  + "!="+ ws.label);
		}
		return undefined;
	}
	
	function getWorkspaceIdFromClassName(type)
	{
		for (var wsi = 0; wsi < workspaces.length; wsi++)
		{
			var ws = workspaces[wsi];
			if (type == ws.label)  return ws.id;
		}
		return "";
	}
	
	/**
	 * This is used to find what is connected to a input-pin
     * Only used to get whats connected to DynInput objects such as AudioMixer and AudioMixerStereo
	 * @param {Array} nns array of all nodes
	 * @param {String} wsId workspace id
	 * @param {String} nId node id
	 * @returns {*} as {node:n, srcPortIndex: srcPortIndex}
	 */
	function getWireInputSourceNode(node, port)
	{
		//console.log("try get WireInputSourceNode:" + wsId + ":" + nId);
		/*for (var ni = 0; ni < nns.length; ni++)
		{
			var n = nns[ni];
			if (n.z != wsId) continue; // workspace check

			var retVal = RED.nodes.eachWire(n, function(srcPortIndex,dstId,dstPortIndex)
			{
				if (dstId == nId)
				{
					//console.log("we found the WireInputSourceNode! name:" + n.name + " ,id:"+ n.id + " ,portIndex:" + srcPortIndex);
					//console.log("");
					return {node:n, srcPortIndex: srcPortIndex}; // this is returned inside RED.nodes.eachWire function
				}
			});
			if (retVal) return retVal;
		}*/
        if (port == undefined) port = 0; // default
        var _links = links.filter(function(l) { return ((l.target === node) && (l.targetPort == port)); });
        //console.log("_links:" + node.name ,_links);
        if (_links.length == 0) return undefined;
        // there is only be one link found
        return {node:_links[0].source, srcPortIndex:_links[0].sourcePort};
	}
	/**
	 * This is used to count the amount of inputs that a unknown type has
	 * @param {Array} nns array of all nodes
	 * @param {String} wsId workspace id
	 * @param {String} nId node id
	 * @returns {*} as {node:n, srcPortIndex: srcPortIndex}
	 */
	function getNodeInputCount(nns, wsId, nId)
	{
		var count = 0;
		for (var ni = 0; ni < nns.length; ni++)
		{
			var n = nns[ni];
			if (n.z != wsId) continue; // workspace check

			var retVal = RED.nodes.eachWire(n, function(srcPortIndex,dstId,dstPortIndex)
			{
				if (dstId == nId)
				{
					//console.log("we found the WireInputSourceNode! name:" + n.name + " ,id:"+ n.id + " ,portIndex:" + srcPortIndex);
					//console.log("");
					return true; // this is returned inside RED.nodes.eachWire function
				}
			});
			if (retVal == true) count++;
		}
		return count;
	}
	
	/**
	 * the name say it all
	 * @param {Array} tabIOnodes array of specific ClassPort nodes
	 * @param {node} classNode as nodeType
	 * @param {Number} portIndex
	 * @returns {node} the TabInput or TabOutput node
	 */
	function getClassPortNode(tabIOnodes, classNode, portIndex)
	{
		var wsId = getWorkspaceIdFromClassName(classNode.type);
		var portType;
		if (tabIOnodes.length > 0)
			portType = tabIOnodes[0].type;
		var currIndex = 0;
		//console.log("getClassPortNode classNode:" + classNode.name + ", portType: " + portType + ", portIndex:" + portIndex);
		for (var i = 0; i < tabIOnodes.length; i++)
		{
			var n = tabIOnodes[i];
			if (n.z != wsId) continue;
			if (currIndex == portIndex) // we found the port
			{
				//console.log("getClassPortNode found port:" + n.name);
				return n;
			}
			currIndex++;
		}
		var port
		console.log("ERROR! could not find the class, portType:" + portType + " with portIndex:" + portIndex);
	}
	
	function classOutputPortToCpp(nns, tabOutNodes, ac, classNode)
	{
		var outputNode = getClassPortNode(tabOutNodes, classNode, ac.srcPort);
		if (!outputNode)
		{
			 console.log("could not getClassPortNode:" + classNode.name + ", ac.srcPort:" + ac.srcPort);
			 return false;
		} // abort

		// if the portNode is found, next we get what is connected to that port inside the class
		var newSrc = getWireInputSourceNode(getNode(outputNode.id), 0); // this return type {node:n, srcPortIndex: srcPortIndex};
        console.error(newSrc);
        if (newSrc == undefined) return false;
        
		ac.srcName += "." + make_name(newSrc.node);
		ac.srcPort = newSrc.srcPortIndex;

		if (isClass(newSrc.node.type))
		{
			//console.log("isClass(" + newSrc.node.name + ")");

			// call this function recursive until non class is found
			if (!classOutputPortToCpp(nns, tabOutNodes, ac, newSrc.node))
				return false; // failsafe
		}
		return true;
	}

	function classInputPortToCpp(tabInNodes, currRootName, ac, classNode)
	{
		var inputNode = getClassPortNode(tabInNodes, classNode, ac.dstPort);
		if (!inputNode) return false; // abort

		// here we need to go througt all wires of that virtual port
		var retVal = RED.nodes.eachWire(inputNode, function(srcPortIndex,dstId,dstPortIndex)
		{
			var dst = RED.nodes.node(dstId);
			//console.log("found dest:" + dst.name);
			ac.dstPort = dstPortIndex;
			ac.dstName = currRootName + "." + make_name(dst);

			if (dst._def.isClass != undefined) // isClass(dst.type))
			{
				// call this function recursive until non class is found
				classInputPortToCpp(tabInNodes, ac.dstName, ac, dst);
			}
			else
			{
				ac.appendToCppCode(); // this don't return anything, the result is in ac.cppCode
			}					
		});
		return true;
	}

	function getArrayDeclarationWithoutSizeSyntax(name)
	{
		var value = 0;
		//console.warn("isNameDeclarationArray: " + name);
		var startIndex = name.indexOf("[");
		if (startIndex == -1) return name;
		var endIndex = name.indexOf("]");
		if (endIndex == -1){ console.log("isNameDeclarationArray: missing end ] in " + name); return name;}
		var arrayDef = name.substring(startIndex,endIndex+1); // this includes the []
		//var valueDef = name.substring(startIndex+1,endIndex)
		return name.replace(arrayDef, "[]");
	}
	
	
	//var AceAutoCompleteKeywords = null;
	/**
	 * this takes both the current workspace node-names and also the external AceAutoCompleteKeywords
	 * @param {String} wsId 
	 */
	function getWorkspaceNodesAsCompletions(wsId) // this is used by ace editor for autocompletions
	{
		/*if (AceAutoCompleteKeywords == null) // if not allready loaded the data
		{
			var aackw_json = $("script[data-container-name|='AceAutoCompleteKeywordsMetadata']").html(); // this cannot happen globally because of the load order in html
			//console.log(aackw_json);
			var aackw_metaData = $.parseJSON(aackw_json);
			AceAutoCompleteKeywords = aackw_metaData["AceAutoCompleteKeywords"];
		}*/

		var items = []; // here we will append current workspace node names
		for (var ni = 0; ni < nodes.length; ni++)
		{
			var n = nodes[ni];
			if (n.z != wsId) continue; // workspace filter
			//if (RED.arduino.export.isSpecialNode(n.type)) continue;
			if (n.type == "Function")
			{
				getFunctions(n, items);
			}
            else if (n.type == "Variables")
            {
                getVaribles(n, items);
            }
			if (n._def.nonObject != undefined) continue;
			var data = RED.NodeHelpManager.getHelp(n.type); //  $("script[data-help-name|='" + n.type + "']").html();
			//var firstP = $("<div/>").append(data).children("div").first().html();
			if (data == undefined) data = n.type;
			else
			{
				var div = document.createElement('div');
				
				div.innerHTML = data.trim();
				var headerElements = div.getElementsByTagName("h3");
				var notes = "<h4>Notes</h4>";
				for (var i2 = 0; i2 < headerElements.length; i2++)
				{
					if (headerElements[i2].textContent == "Notes")
					{
						var eleSibl = headerElements[i2].nextElementSibling;
						while(eleSibl)
						{
							notes += eleSibl.outerHTML;
							eleSibl = eleSibl.nextElementSibling;
						}
						//notes = headerElements[i2].nextElementSibling.innerHTML;
						//console.log("notes:" + notes);
						break;
					}
				}
				var summary = "<h4>Summary</h4>" + $("<div/>").append(data).children("div").first().html();
				data = summary +"<br>"+ notes;
			}
			
			var name = getArrayDeclarationWithoutSizeSyntax(n.name);
			if (name.endsWith("]"))
				items.push({ name:name, snippet:name.replace("[]","[${1}]"), value:name, type:n.type, html: data, meta: n.type, score:(1000)  });
			else
				items.push({ name:name, value:name, type:n.type, html: data, meta: n.type, score:(1000)  });
		}
		AceAutoComplete.Extension.forEach(function(kw) { // AceAutoCompleteKeywords is in AceAutoCompleteKeywords.js
			items.push(kw);
		});
		return items;
	}
	function getAllFunctionNodeFunctions(wsId)
	{
		var items = [];
		for (var ni = 0; ni < nodes.length; ni++)
		{
			var n = nodes[ni];
			if (n.z != wsId) continue; // workspace filter
			//if (RED.arduino.export.isSpecialNode(n.type)) continue;
			if (n.type == "Function")
			{
				getFunctions(n, items);
			}
		}
		return items;
	}
	function getFunctions(functionNode, completeItems)
	{
		var functions = [...functionNode.comment.matchAll(/\s*(unsigned|signed)?\s*(void|int|byte|char|short|long|float|double|bool)\s+(\w+)\s*(\([^)]*\))\s*/g)];
		//var functionsStr = "Functions("+functions.length+"):\n";
		//console.error("functions.length:" + functions.length + ' @ "' + n.name + '"');
		for (var fi = 0; fi < functions.length; fi++)
		{					
			//if (functions[fi] == undefined) continue;
			if (functions[fi][1] == undefined) functions[fi][1] = "";
			var returnType = functions[fi][1] + " " + functions[fi][2].trim();
			var name = functions[fi][3].trim();
			var param = functions[fi][4].trim();
			//console.error(functions[fi]);
			completeItems.push({ name:(name+param), value:(name+param), type:returnType, html: "@ " + functionNode.name + "<br> returns " + returnType, meta: returnType, score:(1000)  });
		}
	}
    function getVaribles(varNode, completeItems)
    {
        //var vars = [...varNode.comment.matchAll(/(?:\w+\s+)([a-zA-Z_][a-zA-Z0-9_]*)\s*[\[;,=]/g)];
        //var vars = [...varNode.comment.matchAll(/\b(?:(?:auto\s*|const\s*|unsigned\s*|signed\s*|register\s*|volatile\s*|static\s*|void\s*|short\s*|uint8_t\s*|uint16_t\s*|uint32_t\s*|uint64_t\s*|int8_t\s*|int16_t\s*|int32_t\s*|int64_t\s*|long\s*|char\s*|int\s*|float\s*|double\s*|bool\s*|complex\s*)+)(?:\s+\*?\*?\s*)([a-zA-Z_][a-zA-Z0-9_]*)\s*[\[;,=)]/gm)];
        var vars = [...varNode.comment.matchAll(/^[ \t]*(?!return|typedef)((\w+[ \t,]*\*?[ \t,]+)+)*(\w+)(\[\w*\])?([ \t,]*=\s*(\w)|;)/gm)];
        for (var fi = 0; fi < vars.length; fi++)
		{		
            //console.error(vars[fi]);
            			
			//if (vars[fi] == undefined) continue;
			if (vars[fi][1] == undefined) vars[fi][1] = "";
			var returnType = vars[fi][1].trim();
			var name = vars[fi][3].trim();
			//var param = vars[fi][6].trim();
			//console.error(functions[fi]);
			completeItems.push({ name:(name), value:(name), type:returnType, html: "@ <b>" + varNode.name + "</b><br> " + vars[fi][0], meta: returnType, score:(1000)  });
		    
        }
    }
	/**
	 * function used by addClassTabsToPalette()
	 */
	function getClassNrOfInputs(nns, classUid)// Jannik add function
	{
		var count = 0;
		for (var i = 0; i  < nns.length; i++)
		{
			var n = nns[i];
			if (n.z == classUid)
			{
				if (n.type == "TabInput")
				{
					count++;
					//console.log("TabInput:" + n.name);
				}
			}
		}
		return count;
	}
	/**
	 * function used by addClassTabsToPalette()
	 */
	function getClassNrOfOutputs(nns, classUid)// Jannik add function
	{
		var count = 0;
		for (var i = 0; i  < nns.length; i++)
		{
			var n = nns[i];
			if (n.z == classUid)
			{
				if (n.type == "TabOutput")
				{
					count++;
					//console.log("TabOutput:" + n.name);
				}
			}
		}
		return count;
	}

	function removeClassNodes(type)
	{
		for ( var ni = 0; ni < nodes.length; ni++)
		{
			var n = nodes[ni];
			//console.log("n.type:" + n.type); // debug
			if (n.type != type)  continue;

			removeNode(n.id);
		}
	}
	
	function refreshClassNodes()// Jannik add function
	{
	    //console.warn("refreshClassNodes");
	    for ( var wsi = 0; wsi < workspaces.length; wsi++)
	    {
		    var ws = workspaces[wsi];
		    //console.log("ws.label:" + ws.label); // debug
		    for ( var ni = 0; ni < nodes.length; ni++)
		    {
			    var n = nodes[ni];
			    //console.log("n.type:" + n.type); // debug
			    if (n.type != ws.label)  continue;
			   
			    // node is class
				//console.log("updating " + n.type);
				var node = RED.nodes.node(n.id);
				var def = RED.nodes.getType(n.type); // refresh type def
				if (def == undefined)
				{
					console.error("@refreshClassNodes: node._def is undefined!!!")
					continue;
				}
				//else
				//	console.error(def);
				node._def = def;
				var newInputCount = getClassNrOfInputs(nodes, ws.id);
				var newOutputCount = getClassNrOfOutputs(nodes, ws.id); 
				
				//var doRemoveUnusedWires = false;
				//if ((newInputCount < node._def.inputs) || (newOutputCount < node._def.outputs)) // this dont work at the moment
				//	doRemoveUnusedWires = true;
				//console.error("newInputCount:" + newInputCount + " oldInputCount:" + node._def.inputs);
				//console.error("newOutputCount:" + newOutputCount + " oldOutputCount:" + node._def.outputs);

				// set defaults
				node._def.inputs = newInputCount;
				node._def.outputs = newOutputCount;
				// update this because that is whats used in view redraw
				node.outputs = node._def.outputs;

				//if (doRemoveUnusedWires)// this dont work at the moment
					removeUnusedWires(node); // so updating all for now

				node.resize = true; // trigger redraw of ports
				node.dirty = true;
			   
		    }
		}
		
	}
	function getJunctionSrcNode(junctionNode)
	{
		for (var i = 0; i < links.length; i++)
		{
			var lnk = links[i];
			if (lnk.target === junctionNode)
			{
				if (lnk.source.type.startsWith("Junction"))
					return getJunctionSrcNode(lnk.source);
				else
					return lnk.source;
			}
		}
		return null;
	}
	function getJunctionDstNodeEquals(junctionNode, dstNode)
	{
		var found = false;
		for (var i = 0; i < links.length; i++)
		{
			var lnk = links[i];
			if (lnk.source === junctionNode)
			{
				if (lnk.target.type.startsWith("Junction"))
					found = getJunctionDstNodeEquals(lnk.target, dstNode);
				else
					found = lnk.target == dstNode;

				if (found) return true;
			}
		}
		return false;
	}
	function removeUnusedWires(node)
	{
		//console.log("check and remove Unused Wires: " + node.type);
		for (var i = 0; i < links.length; i++)
		{
			if (links[i].source == node)
			{
				if (links[i].sourcePort > (node._def.outputs - 1))
				{
					links.splice(i, 1);
				}
			} 
			else if (links[i].target == node)
			{
				if (links[i].targetPort > (node._def.inputs - 1))
				{
					links.splice(i, 1);
				}
			}
		}
	}
	function addClassTabsToPalette()// Jannik add function
	{
		//console.warn("addClassTabsToPalette");
		RED.palette.clearCategory("tabs");
		for (var i=0; i < workspaces.length; i++)
		{
            var ws = workspaces[i];
            if (ws.isMain == true) continue; // never add main file to tabs cat.
			var inputCount = getClassNrOfInputs(nodes, ws.id);
			var outputCount = getClassNrOfOutputs(nodes, ws.id);

            initClassNodeDefCategory();
			registerType(ws.label, getClassNodeDefinition(ws.label, inputCount, outputCount), "classNodes");
		}
	}
    function getClassNodeDefinition(shortName, inputCount, outputCount) {
        return {
            defaults:{
                name:{type:"c_cpp_name"},
                id:{}
            },
            shortName: shortName, isClass:"",inputs:inputCount, outputs:outputCount ,category:"tabs",color: RED.main.classColor ,icon:"arrow-in.png"};
    }
	/*function checkIfTypeShouldBeAddedToUsedCat(nt)
	{
		if (nt == "TabInput") return false;
		else if (nt == "TabOutput") return false;
		else if (nt == "Comment") return false;
		else if (nt == "ClassComment") return false;
		else if (nt == "PointerArray") return false;
		else if (nt == "Function") return false;
		else if (nt == "AudioStreamObject") return false;
		else if (nt == "CodeFile") return false;
		else if (nt == "unknown") return false;
		else if (isClass(nt)) return false;
		return true;
	}*/
	function addUsedNodeTypesToPalette()
	{
		//console.trace("addUsedNodeTypesToPalette");
		RED.palette.clearCategory("used");
		for (var i = 0; i < nodes.length; i++)
		{
			var n = nodes[i];
			if (n._def.nonObject != undefined) continue; // _def.nonObject is defined in index.html @ NodeDefinitions only for special nodes
			if (n._def.isClass != undefined) continue;
			if (n.unknownType != undefined) continue;
			if (n._def.category == undefined) {console.error("error at addUsedNodeTypesToPalette(): nodes[i].type=" + n.type); continue;}
			if (n._def.category.startsWith("input")) continue;
			if (n._def.category.startsWith("output")) continue;
			if (n._def.category.startsWith("control")) continue;

			RED.palette.add(n.type, n._def, "used");
				//console.error(nodes[i].type);
		}
	}
	function make_name(n) {
		var name = (n.name ? n.name : n.id);
		name = name.replace(" ", "_").replace("+", "_").replace("-", "_");
		return name
	}
    function init() {
        Init_BuiltIn_NodeDefinitions();
        RED.events.on("nodes:inputs", NodeInputsChanged);
    }
    function NodeInputsChanged(node, oldCount, newCount) {
        // update the visuals
        if (newCount >= oldCount) {
            RED.events.emit("nodes:inputsUpdated", node, oldCount, newCount);
            return;
        }

        var linksToRemove = links.filter(function(l) { return (l.target === node) && (l.targetPort > (newCount-1)); });
        for (var i = 0; i < linksToRemove.length; i++)  {
            var link = linksToRemove[i];
            var index = links.indexOf(link);
            if (index != -1) {
                links.splice(index,1);
            }
        }
        console.error("links removed");
        RED.events.emit("nodes:inputsUpdated", node, oldCount, newCount, linksToRemove);

        RED.view.redraw();
    }
    function FindNextFreeInputPort(node) {
        var _links = links.filter(function(l) { return (l.target === node); });
        if (_links.length == 0) return 0; // first index
        let index = 0;
        let inputs = node.inputs ? node.inputs: node._def.inputs ? node._def.inputs : 0;
        if (inputs == 0) return -1; 
        //console.error(_links);
        _links.sort(function(a,b){ return (a.targetPort - b.targetPort); });
        for (let i = 0; i < _links.length ; i++,index++) {
            if (_links[i].targetPort == index) continue;
            
            return index;
        }
        if (_links.length == inputs)
            return -1;
        else
            return index;
    }

    function subflowContains(sfid,nodeid) {
        for (var i = 0; i < nodes.length; i++)
        {
            var node = nodes[i];
            if (node.z === sfid)
            {
                var ws = isClass(node.type);
                if (ws) {
                    if (ws.id === nodeid) {
                        return true;
                    } else {
                        var result = subflowContains(ws.id,nodeid);
                        if (result) {
                            return true;
                        }
                    }
                }
            }
            
        }
        return false;
    }

	return {
        subflowContains,
        init:init,
        sortNodes:sortNodes,
        moveWorkspace: function(start, end) {
            if (start > end)
            {
                workspaces.splice(end,0,workspaces[start]);
                workspaces.splice(start+1,1);
                RED.storage.update();
            }
            else if (start < end)
            {

                workspaces.splice(end+1,0,workspaces[start]);
                workspaces.splice(start,1);
                RED.storage.update();
            }
            
            //workspaces[index+1] = workspaces[index];
		    //workspaces[index] = wsTemp;
        },
        FindNextFreeInputPort:FindNextFreeInputPort,
		moveNodeToEnd:moveNodeToEnd,
		createWorkspaceObject:createWorkspaceObject,
		createNewDefaultWorkspace: createNewDefaultWorkspace,
        Init_BuiltIn_NodeDefinitions:Init_BuiltIn_NodeDefinitions,
        registerGroups:registerGroups,
        registerTypes:registerTypes,
		registerType: registerType,
        initNodeDefinitions:initNodeDefinitions,
		getType: getType,
		convertNode: convertNode,
		selectNode: selectNode,
		getJunctionSrcNode:getJunctionSrcNode,
		getJunctionDstNodeEquals:getJunctionDstNodeEquals,
		add: addNode,
		addLink: addLink,
		remove: removeNode,
		removeLink: removeLink,
		addWorkspace: addWorkspace,
		removeWorkspace: removeWorkspace,
		workspace: getWorkspace,
		eachNode: function(cb) {
			for (var n=0;n<nodes.length;n++) {
				cb(nodes[n]);
			}
		},
		eachLink: function(cb) {
			for (var l=0;l<links.length;l++) {
				cb(links[l]);
			}
		},
		getEachLink:getEachLink,
		eachConfig: function(cb) {
			for (var id in configNodes) {
				if (configNodes.hasOwnProperty(id)) {
					cb(configNodes[id]);
				}
			}
		},
		eachWire: eachwire,
		workspaceNameChanged:workspaceNameChanged,
		workspaceNameCheck:workspaceNameCheck,
		node: getNode,
		namedNode: getNodeByName,
		importWorkspaces:importWorkspaces, // new structure
		import: importNodes,
		refreshValidation: refreshValidation,
		getAllFlowNodes: getAllFlowNodes,
		createExportableNodeSet: createExportableNodeSet,
		createCompleteNodeSet: createCompleteNodeSet,
		id: getID,
		getUniqueName:getUniqueName,
		cppName: createUniqueCppName,
		cppId: createUniqueCppId,
		hasIO: checkForIO,
        hasAudio:checkForAudio,
		generateArrayNode:generateArrayNode,
		isClass:isClass,
		getClassComments:getClassComments,
		getWorkspaceIdFromClassName:getWorkspaceIdFromClassName,
		getWorkspace:getWorkspace,
		getClassPortNode:getClassPortNode,
		getWireInputSourceNode:getWireInputSourceNode,
		getClassIOportsSorted:getClassIOportsSorted,
		getClassIOport:getClassIOport, // used by node port tooltip popup
		classOutputPortToCpp:classOutputPortToCpp,
		classInputPortToCpp:classInputPortToCpp,
		getWorkspaceNodesAsCompletions:getWorkspaceNodesAsCompletions,
		getAllFunctionNodeFunctions:getAllFunctionNodeFunctions,
		getArrayDeclarationWithoutSizeSyntax:getArrayDeclarationWithoutSizeSyntax,
		updateClassTypes: function () {addClassTabsToPalette(); refreshClassNodes(); console.warn("@updateClassTypes");},
		addUsedNodeTypesToPalette: addUsedNodeTypesToPalette,
		addClassTabsToPalette:addClassTabsToPalette,
		refreshClassNodes:refreshClassNodes,
		make_name:make_name,
		selectWorkspace: function (id)
		{
			var ws = getWorkspace(id);
			if (ws != undefined)
			{
				currentWorkspace = ws;
				//console.warn("workspace selected: "+ ws.label + " " + ws.id);
			}
        },
        get currentWorkspace() {return currentWorkspace;},
        getCurrentWorkspace: function() { return currentWorkspace},
        setNodes:function(_nodes) { nodes = _nodes;},
		nodes: nodes, // TODO: exposed for d3 vis
		workspaces:workspaces,
		links: links,  // TODO: exposed for d3 vis
        node_defs: node_defs,
        setIconSets: function(sets) {
            iconSets = sets;
            iconSets["font-awesome"] = RED.nodes.fontAwesome.getIconList();
        },
        getIconSets: function() {
            return iconSets;
        },
        checkName:checkName
	};
})();
